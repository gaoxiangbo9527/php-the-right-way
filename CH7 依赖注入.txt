控制反转、依赖倒置原则、依赖注入和容器的关系：
    如果一个类 A 的功能实现需要借助于类 B，那么就称类 B 是类 A 的依赖，如果在类 A 的内部去实例化类 B，那么两者之间会出现较高的耦合，
    一旦类 B 出现了问题，类 A 也需要进行改造，如果这样的情况较多，每个类之间都有很多依赖，那么就会出现牵一发而动全身的情况，程序会极难
    维护，并且很容易出现问题。要解决这个问题，就要把 A 类对 B 类的控制权抽离出来，交给一个第三方去做，把控制权反转给第三方，就称作控制
    反转（IOC，Inversion Of Control）。

    控制反转是一种遵循了依赖倒置原则的思想。

    控制反转或者说依赖倒置原则常见的实现方式有：依赖注入、服务定位器和、依赖查找。其中依赖查找和服务定位器问题都很多，几乎没人用了。
    很多控制反转的实现方式都有容器的概念，比如说依赖注入和服务定位器。在依赖注入中就称为依赖注入容器，在服务定位器中就称为服务定位容器。
    依赖注入当下最优秀和常用的实现方式。由第三方（也称为 依赖注入容器）来控制依赖，把该依赖通过构造函数、方法等方式注入到类 A 内，这样就
    极大程度的对类 A 和类 B 进行了解耦。

    请务必先看：
        https://zhuanlan.zhihu.com/p/33492169
        https://juejin.im/entry/578b3b13c4c971005ee72181
        http://www.gouguoyin.cn/php/137.html

来自 维基百科：
    依赖注入是一种软件设计模式，允许移除硬编码的依赖，并使更换它们成为可能，不论是在运行时还是编译时。

    这段引用让“依赖注入”这个概念听起来比实际上更复杂了。依赖注入就是为一个组件提供其依赖，要么通过构造方法注入、方法调用注入，要么通过设置属
    性。就是这么简单而已。
    个人补充：更直白一点来说，“注入”就是“传入”的意思，所以“依赖注入”也可以成为“依赖传入”或者“传入依赖”。

基本概念
    我们可以通过一个简单且朴素的例子来说明这个概念。

    在这里，我们有一个 Database 类，它需要一个适配器去和数据库沟通。我们在构造方法中实例化了这个适配器并创建了一个硬依赖。这使得测试非常困
    难,并且意味着 Database 类与该适配器紧密耦合。

        <?php
        namespace Database;

        class Database
        {
            protected $adapter;

            public function __construct()
            {
                $this->adapter = new MySqlAdapter;
            }
        }

        class MysqlAdapter {}

    可以使用依赖注入重构此代码，从而松开了依赖。

        <?php
        namespace Database;

        class Database
        {
            protected $adapter;

            public function __construct(MySqlAdapter $adapter)
            {
                $this->adapter = $adapter;
            }
        }

        class MysqlAdapter {}

    现在我们给 Database 类指定了依赖，而不是它自己创建该依赖。我们甚至可以创建一个方法来接受一个该依赖的参数并且将其设置成那样，又如果
    $adapter 属性是 public 的话，我们可以直接设置它。
    个人补充：把 $adapter 设置为 public 这种方法不可取。

复杂的问题
    如果你曾经读过依赖注入，那么你可能已经见过术语“控制反转”或“依赖倒置原则”。这些都是依赖注入解决的复杂的问题。

    控制反转
        控制反转，顾名思义，通过保持组织控制和我们的对象完全分离来反转对一个系统的控制。从依赖注入的角度来说，这意味着通过在系统中的其他地方
        控制和实例化我们的依赖，从而松开我们的依赖。

        多年来，PHP 框架们已经实现了控制反转，然而，问题变成了，我们正在反转的是控制的哪一部分？并且会反转到哪里去？例如，MVC 框架通常会提
        供一个超级对象或者基本的控制器，其它的控制器必须继承它们才能获得对它们的依赖项的访问权。这是控制反转，然而没有松开依赖，这种方法只是
        移走了这些依赖。

        依赖注入允许我们更优雅地解决这个问题，只在需要的时候注入我们需要的依赖，而完全不需要任何硬编码的依赖。

    SOLID
        单一责任原则（Single Responsibility Principle）
            单一责任原则是关于参与者和高级架构的。它指出“一个类应该只有一个改变的理由”。这意味着每个类都只应该对软件所提供的功能中的一个部
            分负责。这种方法的最大好处是可以提高代码的可复用性。通过把我们的类设计为只去做一件事，我们可以在任何其他的程序中使用（或复用）它
            ，而不需要修改它。

        开放关闭原则（Open/Closed Principle）
            开放关闭原则是关于类设计和特性扩展的。它指出“软件实体（类、模块、函数等）应该对扩展开放，对修改关闭”。这意味着我们应该以这样一
            种方式设计我们的模块、类和函数：当需要一个新的功能时，我们不应该去修改现有的代码，而是去编写将被现的有代码所使用的新代码。实际上
            说，这意味着我们应该编写实现且遵守接口的类，然后类型提示应该依据这些接口而不是特定的类。

            这种方法最大的好处是我们可以非常容易地扩展我们的代码去支持一些新的东西，而不需要修改现有的代码，意味着我们能减少 QA 时间，并且
            大大降低了对应用程序产生负面影响的风险。我们能够更快并且更有信心地去部署新代码。

        里氏替换原则（Liskov Substitution Principle）
            里氏替换原则是关于子类型和继承的。它指出“子类永远不应该破坏父类的类型定义”。或者以 Robert C. Martin 的话来说，子类型必须能够
            替代它们的基类型。

            例如，如果我们有个定义了一个 embed() 方法的 FileInterface 接口，并且我们有 Audio 和 Video 类，它们都实现了
            FileInterface 接口，那么我们可以预期使用 embed() 方法将总是会做我们想做的事。如果我们稍后创建了一个实现了 FileInterface
            接口的 PDF 类或 Gist 类，我们将已经知道并了解 embed() 方法会做什么。这种方法最大的好处是我们有能力趣构建灵活且易于配置的程序
            ，因为当我们将属于某个类型（例如，FileInterface）的一个对象（Audio）更换为另一个对象（PDF）时，我们不需要修改程序中的任何其
            他内容。
            个人补充：上面这个例子虽然也是对的，但是并不是特别好，实际上更像是在说开放关闭原则，可以自行搜索一些其他的例子。

        接口隔离原则（Interface Segregation Principle）
            接口隔离原则是关于业务-逻辑-到-客户端通信的。它指出“不应该强迫客户端去依赖它用不到的方法”。这意味着相较于让所有的类都去实现单个
            庞大的接口，我们应该提供一组更小的、概念更具体的接口，让一个类实现一个或多个接口这样的接口。

            例如，Car 或者 Bus 类应该对 steeringWheel() 方法感兴趣，但是 Motorcycle 或 Tricycle 却不会。相反的，Motorcycle 或
            Tricycle 类会对 handlebars() 方法感兴趣，但 Car 或者 Bus 类却不会。没有必要让所有这些类型的车辆都实现对 steeringWheel()
            和 handlebars() 的支持，因此，我们应该分解源接口。

        依赖倒置原则（Dependency Inversion Principle）
            依赖倒置原则是关于移除分散的类之间的硬链接，从而通过传递一个不同的类就可以利用新的功能。它指出应当“要依赖于抽象，不要依赖于具体”
            。简单地说，这意味着我们的依赖应该是接口/契约或抽象类，而不是具体的实现。我们可以很容易的重构上面的例子去遵守这条原则。

                <?php
                namespace Database;

                class Database
                {
                    protected $adapter;

                    public function __construct(AdapterInterface $adapter)
                    {
                        $this->adapter = $adapter;
                    }
                }

                interface AdapterInterface {}

                class MysqlAdapter implements AdapterInterface {}

            现在 Database 类依赖于一个接口而不是一个具体，这有很多的好处。

            假设我们正在一个团队中工作，而一位同事正在处理该适配器（个人补充，比如修改该适配器的接口）。在我们的第一个例子中，我们必须等待该
            同事完成了这个适配器，然后才能为我们的单元测试正确地 mock 它。现在依赖的是一个接口/契约，我们就能愉快的 mock 该接口，因为我们
            知道我们的同事会基于该契约构建这个适配器。

            这种方法的一个更大的好处是现在我们的代码变得更加可扩展了。如果一年后我们决定我们想迁移到另一种不同类型的数据库，我们可以编写一个
            实现了原始接口的适配器并且注入它，不需要更多的重构了，因为我们可以确信这个适配器遵守了该原始接口所设置的契约。

            个人补充：
                高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。
                抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。

容器
    关于依赖注入容器，你首先应该了解的是它们与依赖注入是不同的东西。容器是一个可以帮助我们实现依赖注入的便利的工具，然而它们却经常被误用去实
    现了一种反模式：服务定位（Service Location）。把一个 DI（依赖注入） 容器作为一个服务定位器注入到你的类中，可以说是创建了一种比你要替
    换的依赖更硬（死）的、对该容器的依赖。它还使你的代码更不透明，最终更加难以测试。

    个人补充，可以看看这两篇文章：
        https://juejin.im/entry/578b3b13c4c971005ee72181
        http://www.gouguoyin.cn/php/137.html

    大多数现代框架都有自己的依赖注入容器，允许你通过配置将你的依赖们绑在一起。这意味着，在实践中你可以编写出与其所基于的框架一样干净和解耦的
    应用程序代码。

延伸阅读
    依赖注入是什么？
    依赖注入：一种类比
    依赖注入:嗯?
    作为一种测试工具的依赖注入
