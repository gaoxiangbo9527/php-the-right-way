我发现的关于 PHP 安全的最好资源是 Paragon Initiative 发布的 The 2018 Guide to Building Secure PHP Software 。

Web 应用程序的安全性
    对于每个 PHP 开发人员来说，学习 web 应用程序安全性的基础知识 是非常重要的，它可以被分解成几个宽泛的主题：
        1. 代码和数据分离。
            当数据被作为代码执行，你会遇到 SQL 注入、跨站点脚本编写、本地/远程文件包含等问题。
            当代码作为数据被打印出来时，就会出现信息泄漏（源代码泄露，或者，对于 C 程序，有足够的信息可以绕过 ASLR）。
        2. 应用程序逻辑。
            缺少身份验证或授权控制。
            输入验证。
        3. 操作环境。
            PHP 版本。
            第三方库。
            操作系统。
        4. 密码学弱点。
            弱随机数。
            选择密文攻击。
            边信道信息泄漏。

    有些坏人已经准备好并且愿意利用你的 web 应用程序。采取必要的预防措施来加强 web 应用程序的安全性是很重要的。幸运的是，开放 Web 应用程序安
    全项目（OWASP） 的优秀人员已经编制了一份全面的已知的安全问题和保护你自己免受这些问题影响的方法列表。对于注重安全的开发人员来说，这是一个
    必读的内容。Padraic Brady 所著的 在困境中生存：PHP 安全 也是另一份很好的 PHP web 应用程序的安全指南。

    请阅读 OWASP 的安全指南

密码哈希
    每个构建 PHP 应用程序的人终究要依赖于用户登陆。用户名和密码被存储在一个数据库中并且稍后被用于在登录时去验证用户。

    在存储密码之前先正确的散列密码是重要的。散列和加密是两种非常不同的事情，它们经常被搞混。

    散列是一个不可逆的、单向的函数。它产出一个固定长度的、不可能逆转的字符串。这意味着你可以把一个散列与另外一个散列相比较从而判断二者是否来
    自于相同的源字符串，但是你无法得到原始的字符串。如果密码没有被散列并且你的数据库会被一个未授权的第三方访问，那么现在所有的用户帐户都泄露了。

    不像散列，加密是可逆的（只要你有密钥）。加密在其他领域是有用的，但对于安全的存储密码来说却是一种糟糕的策略。

    还应该在散列之前通过向每个密码添加一个随机字符串，从而对密码进行单独的加盐。这可以防止字典攻击和“彩虹表”(一份常见密码的加密散列的反向列表
    )的使用。

    散列和加盐是非常重要的，因为用户通常会对多个服务使用相同的密码，而且密码的质量可能很差。

    另外，你应该使用一种 专门的密码散列算法 ，而不是快速的、通用目的的加密散列函数（例如 SHA256）。以下是可接受的密码散列算法（截至 2018 年
    6 月）的简短列表：
        Argon2 （在 PHP 7.2 和更新版本中可用)
        Scrypt
        Bcrypt （PHP 为你提供了这个；见下文）
        带 HMAC-SHA256 或 HMAC-SHA512 的 PBKDF2

    幸运的是，现在的 PHP 使这变得很容易。

    使用 password_hash 散列密码
        password_hash() 在 PHP 5.5 中被引入。此时，它使用的是 BCrypt，PHP 目前支持的最强算法。在将来，它会被更新以支持更多的算法需求。
        创建了 password_compat 库，它可以为 PHP >= 5.3.7 提供向前兼容。

        下面我们散列一个字符串，然后检查该散列与一个新字符串。由于两个源字符串是不同的（secret-password 和 bad-password），所以登陆将会
        失败。

        <?php
        require 'password.php';

        $passwordHash = password_hash('secret-password', PASSWORD_DEFAULT);

        if (password_verify('bad-password', $passwordHash)) {
            // Correct Password
        } else {
            // Wrong password
        }

        password_hash() 会为你处理好密码加盐。盐、算法和“成本”会作为散列的一部分被存储。

        password_verify() 会提取这些信息以确定如何检查密码，所以你不需要一个单独的数据库字段来存储盐。

            了解 password_hash()
            针对 PHP >= 5.3.7 && < 5.5 的 password_compat
            了解与密码学有关的散列
            了解盐
            PHP password_hash() 的 RFC

数据过滤
    永远不要相信引入到你的 PHP 代码中的外部输入。总是应在代码中使用它之前先进行清理和验证。filter_var() 和 filter_input() 函数可以清理
    文本和验证文本的格式（例如电子邮件地址）。

    外部输入可以是任何东西：$_GET 和 $_POST 表单输入数据，超全局变量 $_SERVER 中的一些值，和通过 fopen('php://input', 'r') 获得的
    HTTP 请求主体。请记住，外部输入并不局限于用户提交的表单数据。上传和下载的文件、会话值、cookie 数据，以及来自第三方 web 服务的数据也都
    是外部输入。

    虽然外部数据可以被存储、被组合和稍后访问，但它仍然是外部输入。每次你处理、输出、连接，或包含数据到你的代码中时，都要问问你自己这些数据是
    否都经过了适当的过滤并且是否可以相信。

    根据数据的目的可能会对其进行不同的过滤。例如，当未过滤的外部输入被传递进 HTML 页面输出时，它可以在你的站点上执行 HTML 和 JavaScript！
    这称为跨站脚本（XSS）并且可能是一种非常危险的攻击。一种避免 XSS 的方法是在把所有用户生成的数据输出你的到页面之前先对其进行清理，通过使用
    strip_tags() 函数移除 HTML 标签，或者使用 htmlentities() 或 htmlspecialchars() 函数把具有特殊含义的字符转义成它们相应的 HTML
    实体。

    另一个例子是传递要在命令行上执行的选项。这可能是非常危险的（而且通常是一个坏主意），但是你可以使用内置的 escapeshellarg() 函数来清理被
    执行的命令的参数。

    最后一个示例是接受外部输入以确定一个要从文件系统加载的文件。可以通过将文件名更改为一个文件路径就能利用这一点。你需要移除 "/"，"../"，
    null 字节或文件路径中的其他字符，这样它就不能加载隐藏的、非公开的或敏感的文件。

        了解数据过滤
        了解 filter_var
        了解 filter_input
        了解 null 字节处理

    清理
        清理会从外部输入中移除（或转义）非法或不安全的字符。

        例如，当你把输入包含到 HTML 中或者把它插入到一条原生的 SQL 查询中之前，你应该先清理外部输入。当你在 PDO 中使用绑定参数时，它将为你
        清理输入。

        当把输入包含到 HTML 页面中时，有时会需要在输入中允许一些安全的 HTML 标签。这是很难做到的，尽管为此已经存在一些如 HTML Purifier
        的白名单库了，但是许多人还是通过使用其他更严格的格式，如 Markdown 或 BBCode，来避开这个问题。

        查看清理过滤器

    反序列化
        unserialize() 来自用户或者其他不可信源的数据是危险的。这样做可以允许恶意用户实例化对象（使用用户定义的属性）并执行其析构函数，即使
        对象本身没有被使用。因此，你应该避免反序列化不受信任的数据。

        如果你必须反序列化来自不可信源的数据，请使用 PHP 7 的 allowed_classes 选项来限制允许对哪些对象类型进行反序列化。

    验证
        验证可以确保外部输入是你所期望的。例如，当在处理一个注册提交时，你可能希望去验证一个电子邮件地址、一个电话号码或年龄。

        查看验证过滤器

配置文件
    当为你的应用程序创建配置文件时，最佳实践建议遵循以下方法之一：
        建议你将配置信息存储在无法直接访问和通过文件系统提取的位置。个人补充：一般就是要把它放在文档根目录外。
        如果你必须将配置文件存储在文档根目录中，请使用 .php 扩展名命名这些文件。这确保了即使直接访问该脚本，它也不会以纯文本的形式输出。
        配置文件中的信息应该通过加密或用户组/用户文件系统权限得到相应的保护。
        确保不向源代码控制系统提交包含敏感信息（如密码或 API 令牌）的配置文件是一个好主意。

注册全局变量
    注意：从 PHP 5.4.0 开始，register_globals 设置项已经被移除并且不能再使用。之所以会包含此部分，只是作为一个对升级遗留应用程序过程中的
    任何人的警告。

    个人补充：如上所述，就不翻译本小节中剩余的内容了。

错误报告
    记录错误日志对于查找你的应用程序中的问题点非常有用，但是它也能把关于你的应用程序结构方面的信息暴露给外界。为了有效地保护你的应用程序不受
    输出这些消息而可能引起的问题的影响，你需要在开发和生产（线上）中以不同的方式配置你的服务器。

    开发
        为了在开发期间显示每一条可能的错误，在你的 php.ini 中配置下面这些设置项：
            display_errors = On
            display_startup_errors = On
            error_reporting = -1
            log_errors = On

        php.net —— 传递值 -1 将会显示每一种可能的错误，即使当新的错误和常量被添加到将来的 PHP 版本中。从 PHP 5.4 开始，常量 E_ALL 的行
        为也是这样。

        E_STRICT 错误级别常量是在 5.3.0 被引入的并且不是 E_ALL 的一部分，然而在 5.4.0 中，它成为了 E_ALL 的一部分。这意味着什么？从在
        5.3 版本中报告每一种可能的错误的角度来看，它意味着你必须使用 -1 或 E_ALL | E_STRICT 。

        报告每一种可能的错误，按 PHP 版本
            < 5.3 -1 或 E_ALL
              5.3 -1 或 E_ALL | E_STRICT
            > 5.3 -1 或 E_ALL

        个人补充：上面说了这么多，无非就是说 -1 理论上要比 E_ALL 好，但是现在很少会有项目还在使用这么低的版本，况且 PHP 也在“异常”化，将
        来很难再添加新的错误级别了，而且就算要加，也不太可能再把新的错误级别算在 E_ALL 以外。总之没必要纠结 -1 还是 E_ALL 。

    生产
        为了在你的生产环境中隐藏错误，将你的 php.ini 配置为：
            display_errors = Off
            display_startup_errors = Off
            error_reporting = E_ALL
            log_errors = On

        在生产中使用这些设置项，错误仍然会被记录到 web 服务器的错误日志中，但不会显示给用户。关于这些设置项的更多信息，请查看 PHP 手册：
            error_reporting
            display_errors
            display_startup_errors
            log_errors

    个人补充：
        php.ini 中建议生产中把 error_reporting 设置为 E_ALL & ~E_DEPRECATED & ~E_STRICT。生产中到底该使用哪个值，值得斟酌。

        使用 E_ALL
            如果你没有及时修复会引发 E_DEPRECATED 或 E_STRICT 错误的代码，那么这两种日志就会大量出现在日志中，因为每次调用那段代码
            都会触发，在高并发系统中这种日志量可能造成很严重的后果。好处就是你会意识到代码中存在会引发 E_DEPRECATED 或 E_STRICT 错
            误的代码，就能立刻去处理。
        使用 E_ALL & ~E_DEPRECATED & ~E_STRICT
            这两种日志不会出现在日志中，日志文件就会比较小。缺点就是你不会意识到代码中存在会引发 E_DEPRECATED 或 E_STRICT 错误的代
            码，更想不起来去修复了。

        个人觉得应该在开发期间尽可能的去解决 E_DEPRECATED 和 E_STRICT 级别的错误。如果是自己开发的代码引发的，就应该立刻去修复。如
        果是第三方代码引发的，先考虑升级，如果没办法通过升级解决，再考虑换掉它，如果不能换掉它，就只能忍受了，千万别去改它的源代码。如果
        开发期间我们能做的都做了，是使用 E_ALL 还是 E_ALL & ~E_DEPRECATED & ~E_STRICT 就只能到时候再根据实际情况决策了。

        另外不论是开发还是生产中，建议通过 error_log 配置指令为 PHP 的错误日志指定一个专用的文件。
